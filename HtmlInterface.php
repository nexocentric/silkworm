<?php
#===============================================================================
// [summary]
// This is a simple interface designed for making it possible to produce
// html tags and documents using PHP. This interfaces always produces
// systematically indented HTML code to ease the reading and visual debugging
// of HTML documents.
//
// This interface has no external dependencies and can be used by including it
// in a PHP file and creating an instance of the class.
// [usage]
// This is a list of public methods. Please see the README.md for more detailed
// documentation on usage.
//
// 1) $html = new HtmlInterface(); // create a new interface
// 2) ... = new HtmlINterface("html"); // create a new interface with doctype
// 3) $html->doctype("html"); // set the doctype
// 4) $html->indentCharacter(" "); // set indent character as tabs or spaces
// 5) $html->html(); // create a tag !!see README.md for more information
// 6) $html->newline(); //create a newline in HTML document
// 7) $html->comment("comment text"); //create a comment in HTML document
// 8) $html->repeat(HtmlInterface, int); //repeat a fragment n times
#===============================================================================
class HtmlInterface
{
    //class constants
    const DOUBLE_QUOTE = "\"";
    const NEWLINE = "\n";
	const SPACE = " ";
	const TAB = "\t";

	//member variables    
	private $parsingHtmlFragment = false;
	private $indentLevel = 0;
	private $indentationPattern = HtmlInterface::TAB;
	private $selfClosingTagList = array(
		"base", 
		"basefont", 
		"br", 
		"col", 
		"frame", 
		"hr", 
		"input", 
		"link", 
		"meta", 
		"param"
	);
	private $booleanAttributes = array(
		"allowfullscreen",
		"async",
		"autofocus",
		"checked",
		"compact",
		"declare",
		"default",
		"defer",
		"disabled",
		"formnovalidate",
		"hidden",
		"inert",
		"ismap",
		"itemscope",
		"multiple",
		"multiple",
		"muted",
		"nohref",
		"noresize",
		"noshade",
		"novalidate",
		"nowrap",
		"open",
		"readonly",
		"required",
		"reversed",
		"seamless",
		"selected",
		"sortable",
		"truespeed",
		"typemustmatch"
	);
	private $doctype = "";
	private $html = "";
	
	#-----------------------------------------------------------
	# [summary]
	# Changes the indentation pattern for the document.
	# [parameters]
	# 1) An indentation pattern consisting of tabs or spaces.
	# [return]
	# none
	#-----------------------------------------------------------
	public function setIndentation($indentationPattern = "")
	{
		//declarations
		$space = HtmlInterface::SPACE;
		$tab = HtmlInterface::TAB;

		//check to see if use entered invalid tab value
		if(preg_match("/[^$space$tab]/", $indentationPattern) === 0) {
			//indentation pattern is valid, use it
			$this->indentationPattern = $indentationPattern;
			return;
		}
		//trigger_error("Only ASCII spaces and tabs can be used for indentation.");
	}#----------------- setIndentation end -----------------#

	#-----------------------------------------------------------
	# [summary]
	# Create a new HtmlInterface for use to create HTML.
	# [parameters]
	# 1) The doctype definition of the HTML document to be
	#    created. This is optional. By setting this a doctype
	#    will be added to the document, otherwise the document
	#    will be generated without a doctype.
	# [return]
	# 1) A new HtmlInterface for use.
	#-----------------------------------------------------------
	public function __construct($definition = "")
	{
	    //check if user wants to set a doctype
		if(!empty($definition)) {
		    //user specified a doctype, so set it
			$this->doctype($definition);
		}
	}#----------------- __construct end -----------------#

	/////////////////////////////////////
	//start magic method implementation->
    #-----------------------------------------------------------
	# [summary]
	# This is an overload of the PHP __call function. This 
	# passes the name of an HTML tag to be generated along with
	# the attributes to be set to the initializeTag function.
	# [parameters]
	# 1) The name of the tag.
	# 2) Tag properies(attributes, innertext, children/siblings)
	# [return]
	# 1) The tag generated by the initializeTag function.
	#-----------------------------------------------------------
	public function __call($tagName, $properties)
	{
	    //parse the tag properties and generate tag of $tagName
		return $this->html = $this->initializeTag($tagName, $properties);
	}#----------------- __call end -----------------#

	#-----------------------------------------------------------
	# [summary]
	# This is an overload of the PHP __toString() function. This
	# prints out the generated HTML data as a printable string.
	# [parameters]
	# none
	# [return]
	# The generated HTML as a string.
	#-----------------------------------------------------------
	public function __toString()
	{
		return $this->doctype . $this->html;
	}#----------------- __toString end -----------------#
	//<-end magic method implementation
	/////////////////////////////////////
	
	#-----------------------------------------------------------
	# [summary]
	# This splits the data passed to it by the __call function
	# into attributes, children and HtmlInterface fragments and
	# passes this information along with the tag name to the
	# createTag function.
	# [parameters]
	# 1) The name of the tag.
	# 2) Tag properies(attributes, innertext, children/siblings)
	# [return]
	# 1) A tag string created by the createTag function.
	#-----------------------------------------------------------
	protected function initializeTag($tagName, $properties)
	{
	    //declarations
		$attributes = array();
		$innerText = "";
		$stringList = array(); //work storage for strings passed to this function
		$children = array();
		
		//go through the complete property list and
		//divide it by property type
		foreach($properties as $property) {
		    //check if this is an HtmlInterface fragment
			//since HtmlInterface has a to __toString method
			//this has to be valuated before any
			//string evaluations
			if($property instanceof HtmlInterface) {
			    //safety for users who set doctypes
			    //on HtmlInterface fragments
				$property->clearDoctype();
				
				//treat the fragment as a child
				$children[] = $property;
				continue;
			}
			//if it has a carriage, it's a chlid
			if(strpos($property, HtmlInterface::NEWLINE) !== false) {
				$children[] = $property;
				continue;
			}
			//these are either attributes or inner text
			if(is_string($property)) {
			    //save for later and check for inner text
				$stringList[] = $property;
				continue;
			}
	    }

	    //set up boolean attributes for parsing
		$stringCount = count($stringList);
		for ($nextString = $stringCount; $nextString > 0; $nextString--) {
			//going backwards through the list because of array slice
	    	$property = $stringList[$nextString - 1];
	    	if(in_array($property, $this->booleanAttributes)) {
	    		//pair the boolean with a blank value
	    		//for parsing purposes only
	    		array_splice($stringList, $nextString, 0, "");
	    	}
		}

	    //begin analyzing the string list
	    $stringCount = count($stringList);
	    //if has a remainder this contains inner text
	    if($stringCount % 2) {
	        //inner text is always last string in list
			$innerText = $stringList[$stringCount - 1];
	    }
	    
	    //pair the rest of the strings as attributes
	    for ($nextString = 0; ($nextString + 1) < $stringCount; $nextString += 2) {
	        //attribute name = attribute value
	        //this makes it easier for the create tag function
	    	$attributes[$stringList[$nextString]] = $stringList[$nextString + 1];
	    }
        
        //create a tag and return it
		return $this->createTag($tagName, $attributes, $innerText, $children);
	}#----------------- initializeTag end -----------------#
    
    #-----------------------------------------------------------
	# [summary]
	# Function for turning the associative attribute array into
	# valid html attributes.
	# [parameters]
	# 1) An associative array of attribute names and values.
	# [return]
	# 1) A string of attributes.
	# 2) If no attributes are set, a blank string is returned.
	#-----------------------------------------------------------
	protected function parseAttributes($attributes)
	{
	    //declarations
	    $space = HtmlInterface::SPACE;
	    $quote = HtmlInterface::DOUBLE_QUOTE;
		$attributeString = ""; //parsed string of attributes
		
		//check if attributes where set
		if(empty($attributes)) {
		    //always return a blank string
			return $attributeString;
		}
		
		//go through the array of attributes
		//and pair them accordingly
		foreach ($attributes as $name => $value) {
			//check if the attribute is a boolean value
		    if(in_array($name, $this->booleanAttributes)) {
				$attributeString .= "$space$name";
				continue;
		    }
			$attributeString .=  "$space$name=$quote$value$quote";
		}
		return $attributeString;
	}#----------------- parseAttributes end -----------------#

    #-----------------------------------------------------------
	# [summary]
	# This increases the indentation of nested children.
	# [parameters]
	# 1) A string of child tags.
	# [return]
	# 1) A string of child tags that have had the indentation 
	#    adjusted.
	#-----------------------------------------------------------
	protected function increaseIndent($childString)
    {
    	//declarations
    	$newline = HtmlInterface::NEWLINE;
    	
        //remove the final carriage because
        //if it's there explode will treat
        //it as an empty string
		$childList = substr_replace(
			$childString,
			"",
			strrpos($childString, $newline)
		);
		
		//split the children into their respective lines
		$childList = explode($newline, $childList);
		
		//go through each and adjust the indentation
		foreach($childList as $index => $child) {
		    // they have to stay at their original index
		    // for order
			$childList[$index] = $this->indent() . $child;
		}
		
		//glue together with carriages and add the final
		//one as well
		return implode($newline, $childList) . $newline;
	}#----------------- increaseIndent end -----------------#
	
	#-----------------------------------------------------------
	# [summary]
	# Parses an array of children by turning them into a string
	# of appropriately indented ones.
	# [parameters]
	# 1) An array of children.
	# [return]
	# 1) A string of parsed children.
	# 2) If no children are present, an empty string.
	#-----------------------------------------------------------
	protected function parseChildren($children)
	{
	    //delcarations
		$childString = "";
		
		//check if children exists
		if(empty($children)) {
		    //return empty string
			return $childString;
		}
		
		//special parse loop for HtmlInterface fragments
		//the top line of a fragment doesn't have a carriage
		//before it, so add it here
		$newline = $this->parsingHtmlFragment ? "" : HtmlInterface::NEWLINE;
		
		//the children for this tag are either
		//a) a single string that missed array formatting
		//b) an HtmlInterface fragment
		if(!is_array($children)) {
		    //convert the children to an array
		    //for parsing
			$children = array($children);
		}
		
		//save the indent level just incase changes
		//must be made
		$currentIndentLevel = $this->indentLevel;
		
		//adjust the indentation of childrent to be nested
		foreach($children as $child) {
			//check if this is an html fragment
			if($child instanceof HtmlInterface) {
				$this->parsingHtmlFragment = true; //start fragment parsing
				
				//the fragment is already indented
				//so don't indent while parsing it to a string
				$this->indentLevel = 0;
				$child = $this->parseChildren((string)$child);
				$this->indentLevel = $currentIndentLevel;
				
				$this->parsingHtmlFragment = false; //end fragment parsing
			}
			//properly indent children
			$child = $this->increaseIndent($child);
			$childString .= $child;
		}
		return $newline . $childString;
	}#----------------- parseChildren end -----------------#
    
    #-----------------------------------------------------------
	# [summary]
	# Creates a tag of with the specified parameters.
	# [parameters]
	# 1) HTML tag name.
	# 2) Tag attributes.
	# 3) Inner text.
	# 4) Children as strings or HTML fragments.
	# [return]
	# 1) The generated tag.
	#-----------------------------------------------------------
	protected function createTag($tagName, $attributes, $innerText = "", $children = "")
	{
		//declarations
		$createdTag = "";
		$newline = HtmlInterface::NEWLINE;
		
		//change sprintf statment for 
		//regular and self closing tags
		if(in_array($tagName, $this->selfClosingTagList)) {
			//self closing
			$newline = $children ? "" : $newline; //newline if no children
			$createdTag = "<$tagName%s>$newline%s%s";
			$this->indentLevel = 0;
		} else {
			//regular tag
			$createdTag = "<$tagName%s>%s%s</$tagName>$newline";
			$this->indentLevel = 1;
		}

		//create the tag
		$createdTag = sprintf(
			"$createdTag",
			$this->parseAttributes($attributes),
			$innerText,
			$this->parseChildren($children)
		);
		
		return $createdTag;
	}#----------------- createTag end -----------------#

    #-----------------------------------------------------------
	# [summary]
	# Removes !DOCTYPE from children if the user accidentally
	# set the !DOCTYPE on HTML fragments.
	#
	# !!NOTICE!!
	# For internal use only.
	# [parameters]
	# none
	# [return]
	# none
	#-----------------------------------------------------------
	protected function clearDoctype()
	{
		$this->doctype = "";	
	}#----------------- clearDoctype end -----------------#
	
	#-----------------------------------------------------------
	# [summary]
	# Sets the !DOCTYPE for this HTML document.
	# [parameters]
	# 1) !DOCTYPE definition
	# [return]
	# none
	#-----------------------------------------------------------
	public function doctype($definition) {
		$this->doctype = sprintf(
			"<!DOCTYPE %s>" . HtmlInterface::NEWLINE,
			$definition
		);
	}#----------------- doctype end -----------------#
	
	#-----------------------------------------------------------
	# [summary]
	# Repeats an HtmlInterface fragment n number of times.
	# [parameters]
	# 1) HtmlInterface fragment.
	# 2) The number of times to repeat the fragment.
	# [return]
	# 1) A string of children repeated n number of times.
	#-----------------------------------------------------------
	public function repeat(HtmlInterface $html, $count)
	{
		$html->clearDoctype();
		return str_repeat($html, $count);
	}#----------------- repeat end -----------------#
	
	#-----------------------------------------------------------
	# [summary]
	# Adds a newline to the document for viusal purposes only.
	# [parameters]
	# none
	# [return]
	# none
	#-----------------------------------------------------------
	public function newline() {
		return HtmlInterface::NEWLINE;
	}#----------------- newline end -----------------#
	
	#-----------------------------------------------------------
	# [summary]
	# Function for controlling the indentation pattern of this
	# document.
	#
	# !!NOTICE!!
	# For internal use only.
	# [parameters]
	# none
	# [return]
	# An indentation pattern.
	#-----------------------------------------------------------
	protected function indent()
	{
		return str_repeat($this->indentationPattern, $this->indentLevel);
	}#----------------- indent end -----------------#

	#-----------------------------------------------------------
	# [summary]
	# Adds an HTML style comment to the document.
	# [parameters]
	# 1) Comment contents.
	# [return]
	# 1) A comment for display.
	#-----------------------------------------------------------
	public function comment($comment)
	{
		return "<!-- $comment -->" . HtmlInterface::NEWLINE;
	}#----------------- comment end -----------------#

	//////////////////////////////
	//start auto table functions->
	private function parseCells($array)
	{
		$cells = "";
		
		foreach($array as $cell) {
			$cells .= $this->initializeTag(
				"td",
				array($cell)
			);
		}
		return $cells;
	}
	
	private function parseRows($array, $rowAttributes)
	{
		$rows = "";
		
		//
		foreach($array as $row) {
			$rowAttributes[] = $this->parseCells($row);
			$rows .= $this->initializeTag(
				"tr",
				$rowAttributes
			);
		}
		
		return $rows;
		
		return "<tr>\n" .
			"\t<td>a</td>\n" .
			"\t<td>b</td>\n" .
			"\t<td>c</td>\n" .
			"</tr>\n" .
			"<tr>\n" .
			"\t<td>d</td>\n" .
			"\t<td>e</td>\n" .
			"\t<td>f</td>\n" .
			"</tr>\n" .
			"<tr>\n" .
			"\t<td>g</td>\n" .
			"\t<td>h</td>\n" .
			"\t<td>i</td>\n" .
			"</tr>\n";
	}

	public function autoTable($array)
	{
		//declarations
		$table = "";
		$rowAttributes = array();
		
		//initializations
		$properties = func_get_args();
		array_splice($properties, 0, 1); //array that the table is to parse
		
		//find the row attributes
		foreach($properties as $property) {
			if(is_array($property)) {
				$rowAttributes[] = $property;
			}
		}

		$properties[] = $this->parseRows($array, $rowAttributes);
		$table = $this->initializeTag(
			"table",
			$properties
		);
		
		return $table;
	}
	//<-end auto table functions
	//////////////////////////////
}#==================== HtmlInterface end ====================#

$table = array(array("a", "b", "c"));

$html = new HtmlInterface();
$html->autoTable($table);